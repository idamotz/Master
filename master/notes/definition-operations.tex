\subsection{Operations}
\label{sub:operations}

We define \emph{operations} to alter the feature model evolution plan. A software product line may grow very large, and the plans even larger. Since different factors may influence the plan, it is necessary to be able to change the plan accordingly. If the plan is indeed extremely large, and since feature models have strict structure constraints, it is also necessary to check \emph{automatically} that the changes do not compromise the structure. Due to the size and complexity of the problem, it is not enough to let a human verify a change. 

\begin{itemize}
  \item \textbf{addFeature(featureID, parentGroupID, name, featureType)} from $t_n$ to $t_m$\\
    Adds feature with id \var{featureID}, name \var{name}, and feature variation type \var{featureType} to the group with id \var{parentGroupID} in the interval $\interval{t_n}{t_m}$. \var{featureID} must be fresh, and the name cannot belong to any other feature in the model during the interval. The parent group must exists during the interval, and the types of the feature and the parent group must be compatible. If the feature has type \textbf{mandatory}, then the parent group must have type \textbf{AND}.
  \item \textbf{addGroup(groupID, parentFeatureID, groupType)} from $t_n$ to $t_m$\\
    Adds group with id \var{groupID} and type \var{groupType} to the feature with id \var{parentFeatureID} during the interval \interval{$t_n$}{$t_m$}. The group ID must be fresh, and the parent feature must exist during the interval. 
  \item \textbf{removeFeature(featureID)} at time $t_n$\\
    Removes the feature with ID \var{featureID} from the feature model at $t_n$ (does not affect possible reintroductions). The \features{} map in the original plan must contain a mapping $\mapping{\var{featureID}}{(\map{existence}, \ldots)}$ such that $\interval{t_i}{t_j} \in \map{existence}$ with $ t_i \leq t_n \leq t_j$. The feature must not have any child groups during $\interval{t_n}{t_j}$. After removing the feature, all interval mappings should be updated from $\interval{t_i}{t_j}$ to $\interval{t_i}{t_n}$.
  \item \textbf{removeGroup(groupID)} at time $t_n$\\
    Removes the group with ID \var{groupID} from the feature model at $t_n$ (does not affect possible reintroductions). The \groups{} map in the original plan must contain a mapping $\mapping{\var{groupID}}{(\map{existence}, \ldots)}$ such that $\interval{t_i}{t_j} \in \map{existence}$ with $t_i \leq t_n \leq t_j$. The group must not have any child features during $\interval{t_n}{t_j}$. After removing the group, all interval mappings should be updated from $\interval{t_i}{t_j}$ to $\interval{t_i}{t_n}$. 
  \item \textbf{moveFeature(featureID, targetGroupID)} at $t_n$\\
    Moves the feature with id \var{featureID} to the group with ID $\var{targetGroupID}$. The move cannot be done if it introduces a cycle; that is, if the target group is in the feature's subtree. The feature's subtree is moved along with it. Parent group and child feature mappings are updated accordingly. 
  \item \textbf{moveGroup(groupID, targetFeatureID)} \\
    Moves the group with id \var{groupID} to the feature with ID $\var{targetFeatureID}$. Very similar to \textbf{moveFeature}. 
  \item \textbf{changeFeatureVariationType(featureID, newType)} \\
    Changes the feature variation type of the feature with ID \var{featureID} to \var{newType}. If the new type is \textbf{mandatory}, the parent group type must be \textbf{AND}. 
  \item \textbf{changeGroupVariationType(groupID, newType)}\\
    Changes the group variation type of the group with ID \var{groupID} to \var{newType}. If the new type is \textbf{OR} or \textbf{XOR}, make sure that no child feature has type \textbf{mandatory}. 
  \item \textbf{changeFeatureName(featureID, name)}\\
    Changes the name of the feature with ID \var{featureID} to \var{name}. No other feature may have the same name.
\end{itemize}

\todo{Look at possibilities for changing intervals; extending, restricting, and moving. This would be equivalent to removing/moving operations in the summer project semantics.}
