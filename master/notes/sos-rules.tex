\section{SOS rules}
\label{sec:sos-rules}


\subsection{Add feature rule}

\begin{figure}[h]
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Add-Feature}
      {\\
        \features{}[\var{fid}] = (F_e,\, F_n,\, F_t,\, F_p,\, F_c) \\
        \groups{}[\var{parentGroupID}] = (G_e,\, G_t , \, G_p,\, G_c)\\
        \interval{t_n}{t_m} \not \innr F_e \qquad
        \interval{t_n}{t_m} \inn G_e \qquad
        \names{}[\var{name}]\interval{t_n}{t_m} = \emptyset \\
        \forall \var{gt}_{\in G_t\interval{t_n}{t_m}} (\var{compatibleTypes}(\var{gt}, \var{type})) \\
      }
      {
        (\names{}, \features{}, \groups{})\\
        :\textbf{addFeature}(\var{fid}, \var{name}, \var{type}, \var{parentGroupID})\text{ at }\interval{t_n}{t_m} \\
      \transition\\
        (\assign{\names{}[\var{name}]\interval{t_n}{t_m}}{\var{fid}}\\
        \assign{\features{}[\var{fid}]}
        {\var{setFeatureAttributes}(\features{}[\var{fid}], \interval{t_n}{t_m}, 
        \var{name}, \var{type}, \var{parentGroupID})},\\
        \assign{\groups{}[\var{parentGroupID]}}
        {\var{addChildFeature}(\groups{}[\var{parentGroupID}], \interval{t_n}{t_m}, \var{fid})})
    }
    \end{array}$$
    \caption{\label{rule:add-feature}}
\end{figure}

Figure \vref{rule:add-feature}  describes the semantics of the \textbf{addFeature} operation. 
To add a feature during the interval $\interval{t_n}{t_m}$, its ID cannot exist exist during the interval ($\interval{t_n}{t_m} \not \innr F_e$). The parent feature must exist ($\interval{t_n}{t_m} \inn G_e$), and the types it has during the interval must be compatible with the type of the 
added feature ($\forall \var{gt}_{\in G_t\interval{t_n}{t_m}} (\var{compatibleTypes}(\var{gt}, \var{type}))$). The name of the feature must be available during the interval ($\names{}[\var{name}]\interval{t_n}{t_m} = \emptyset$). Notice that the default value in the $\features{}$ map lets us treat a failed lookup as a feature, thus allowing us to express the semantics of adding a feature using only one rule. 

To make the rule tidier, we use three helper functions: $\var{compatibleTypes}$ (Figure \vref{fun:compatible-types}), $\var{setFeatureAttributes}$ (Figure \vref{fun:set-feature-attributes}), and $\var{addChildFeature}$ (Figure \vref{fun:add-child-feature}). 

\begin{figure}[h]
  \begin{minted}{text}
compatibleTypes(AND, _) = True
compatibleTypes(_, optional) = False
compatibleTypes(_, _) = True
  \end{minted}
  \caption{\label{fun:compatible-types}}
\end{figure}

\begin{figure}[h]
  \begin{minted}[escapeinside=||]{text}
setFeatureAttributes(|$(F_e, F_n, F_t, F_p, F_c)$|, |$\interval{t_{start}}{t_{end}}$|, name, type, parentGroupID)
  = |$($| |$F_e \cup \interval{t_{start}}{t_{end}}$|
    , |$F_n$|[|$\interval{t_{start}}{t_{end}}$|] |$\leftarrow$| name
    , |$F_t$|[|$\interval{t_{start}}{t_{end}}$|] |$\leftarrow$| type
    , |$F_p$|[|$\interval{t_{start}}{t_{end}}$|] |$\leftarrow$| parentGroupID
    , |$F_c$| |$)$|
     \end{minted}
  \caption{\label{fun:set-feature-attributes}}
\end{figure}

\begin{figure}[h]
  \begin{minted}[escapeinside=||]{text}
addChildFeature(|$(G_e, G_t, G_p, G_c)$|, |$\interval{t_{start}}{t_{end}}$|, fid)
  = |$($| |$G_e, G_t, G_p$|
    , |$G_c \cup \intervalmapping{t_{start}}{t_{end}}{\var{fid}}$| |$)$|
  \end{minted}
  \caption{\label{fun:add-child-feature}}
\end{figure}


\todo{Find a way to express that there are no intervals in $F_e$ overlapping $\interval{t_n}{t_m}$}



\begin{figure}
  
  \caption{\label{rule:add-group}}
\end{figure}
