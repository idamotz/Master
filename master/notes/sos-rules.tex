\section{SOS rules}
\label{sec:sos-rules}
\todo{Consider having two rules for each operation; one for validating and one for updating. Alternatively use functions on the right-hand side of $\transition$.}

\todo{Explain how to read the rules}

\subsection{Add feature rule}
\label{sub:add-feature-rule}

\begin{figure}
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Add-Feature}
      {\\
        \interval{t_n}{t_m} \not \innr F_e \qquad
        \interval{t_n}{t_m} \inn G_e \qquad
        \lookup{\names{}}{\var{name}}\interval{t_n}{t_m} = \emptyset \\
        \lookup{\features{}}{\var{fid}} = \left( F_e,\, F_n,\, F_t,\, F_p,\, F_c \right) \\
        \lookup{\groups{}}{\var{parentGroupID}} = \left(G_e,\, G_t , \, G_p,\, G_c \right)\\
        \forall \var{gt}_{\in G_t\interval{t_n}{t_m}} (\var{compatibleTypes}(\var{gt}, \var{type})) \\
      }
      {
        \textbf{addFeature}(\var{fid}, \var{name}, \var{type}, \var{parentGroupID})\text{ at }\interval{t_n}{t_m} \shove \\
         (\names{}, \features{}, \groups{})\\
        \transition\\
        (\lookup{\names{}}{\var{name}}\interval{t_n}{t_m} \assign \var{fid},  \\
        {\lookup{\features{}}{\var{fid}}} \assign 
        \var{setFeatureAttributes}(\lookup{\features{}}{\var{fid}}, \interval{t_n}{t_m}, 
        \var{name}, \var{type}, \var{parentGroupID}),\\
        {\lookup{\groups{}}{\var{parentGroupID}}} \assign 
        \var{addChildFeature}(\lookup{\groups{}}{\var{parentGroupID}}, \interval{t_n}{t_m}, \var{fid}))
    }
    \end{array}$$
    \caption{\label{rule:add-feature}}
\end{figure}

Figure \vref{rule:add-feature}  describes the semantics of the \textbf{addFeature} operation. 
To add a feature during the interval $\interval{t_n}{t_m}$, its ID cannot exist exist during the interval ($\interval{t_n}{t_m} \not \innr F_e$). The parent feature must exist ($\interval{t_n}{t_m} \inn G_e$), and the types it has during the interval must be compatible with the type of the 
added feature ($\forall \var{gt}_{\in G_t\interval{t_n}{t_m}} (\var{compatibleTypes}(\var{gt}, \var{type}))$). The name of the feature must be available during the interval ($\lookup{\names{}}{\var{name}}\interval{t_n}{t_m} = \emptyset$). Notice that the default value in the $\features{}$ map lets us treat a failed lookup as a feature, thus allowing us to express the semantics of adding a feature using only one rule. 

To make the rule tidier, we use three helper functions: $\var{compatibleTypes}$ (Figure \vref{fun:compatible-types}), $\var{setFeatureAttributes}$ (Figure \vref{fun:set-feature-attributes}), and $\var{addChildFeature}$ (Figure \vref{fun:add-child-feature}). 

\begin{figure}
  \begin{minted}{text}
compatibleTypes(AND, _) = True
compatibleTypes(_, optional) = False
compatibleTypes(_, _) = True
  \end{minted}
  \caption{\label{fun:compatible-types}}
\end{figure}

\begin{figure}
  \begin{minted}[escapeinside=||]{text}
setFeatureAttributes|$((F_e, F_n, F_t, F_p, F_c)$|, |$\interval{t_{start}}{t_{end}}$|, name, type
                    , parentGroupID|$)$|
  = |$($| |$F_e \cup \interval{t_{start}}{t_{end}}$|
    , |$F_n \interval{t_{start}}{t_{end}}$|] |$\assign$| name
    , |$F_t \interval{t_{start}}{t_{end}}$|] |$\assign$| type
    , |$F_p \interval{t_{start}}{t_{end}}$|] |$\assign$| parentGroupID
    , |$F_c \ )$|
     \end{minted}
  \caption{\label{fun:set-feature-attributes}}
\end{figure}

\begin{figure}
  \begin{minted}[escapeinside=||]{text}
addChildFeature|$((G_e, G_t, G_p, G_c), \interval{t_{start}}{t_{end}}, \var{fid})$|
  = |$\left(G_e, G_t, G_p , G_c \interval{t_{start}}{t_{end}} \addassign \var{fid}\right)$|
  \end{minted}
  \caption{\label{fun:add-child-feature}}
\end{figure}


\subsection{Add group rule}
\label{sub:add-group-rule}
The rule in figure \vref{rule:add-group} describes the conditions which must be in place to add a (pre-existing or fresh) group to the FMEP during an interval $\interval{t_n}{t_m}$. The group must not already exist in the plan during the interval $\interval{t_n}{t_m} \notinnr G_e$, and the parent feature must exist for the duration of the interval $\interval{t_n}{t_m} \inn F_e$. The group ID is added to the parent feature's map of child groups with the interval as key, and the attributes specified are added to the group entry in the $\groups$ map.

\begin{figure}
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Add-Group}
      {\\
        \interval{t_n}{t_m} \notinnr G_e \qquad \interval{t_n}{t_m} \inn F_e \\
        \lookup{\groups{}}{\var{groupID}} = (G_e,\, G_t,\, G_p,\, G_c ) \\
        \lookup{\features{}}{\var{parentFeatureID}} = (F_e,\, F_n,\, F_t,\, F_p,\, F_c ) 
      }
      {
        \textbf{addGroup}( \var{groupID}, \var{type}, \var{parentFeatureID} ) \text{ at } \interval{t_n}{t_m} \shove \\
        ( \names{}, \features{}, \groups{} ) \\
        \transition \\
        (\names{}, \\
        \lookup{\features{}}{\var{parentFeatureID}} \assign (F_e,\, F_n,\, F_t,\, F_p ,\, F_c \cup \intervalmapping{t_n}{t_m}{\var{groupID}} ), \\ 
      {\lookup{\groups{}}{\var{groupID}}} \assign 
             \var{setGroupAttributes}( \lookup{\groups{}}{\var{groupID}}, \var{type}, \var{parentFeatureID} )  )
      }
    \end{array}$$
  \caption{\label{rule:add-group}}
\end{figure}

\begin{figure}
  \begin{minted}[escapeinside=||]{text}
setGroupAttributes(|$(G_e, G_t, G_p, G_c)$|, |$\interval{t_{start}}{t_{end}}$|, type
                  , parentFeatureID)
  = |$($| |$G_e \cup \interval{t_{start}}{t_{end}}$|
    , |$G_t \interval{t_{start}}{t_{end}}$| |$\assign$| type
    , |$G_p \interval{t_{start}}{t_{end}}$| |$\assign$| parentFeatureID
    , |$G_c )$|
     \end{minted}
  \caption{\label{fun:set-group-attributes}}
\end{figure}

\begin{figure}
  \begin{minted}[escapeinside=||]{text}
addChildGroup|$\left(\left(F_e, F_n, F_t, F_p, F_c \right), \,\interval{t_{start}}{t_{end}}, \, \var{gid}\right)$|
  = |$\left(F_e,\, F_n,\, F_t,\, F_p,\, F_c \interval{t_{start}}{t_{end}} \addassign \var{gid}\right)$|
  \end{minted}
  \caption{\label{fun:add-child-group}}
\end{figure}

\subsection{Remove feature rule}
Figure \vref{rule:remove-feature} shows the semantics of removing a feature with ID $\var{featureID}$ at time $t_n$. We find the time point when the feature was to be removed in the original plan by looking up the interval containing $t_n$ in the feature's $\map{existence}$ map $\interval{t_{e_1}}{t_{e_2}}$. The interval in which the new plan is different from the original is then $\interval{t_n}{t_{e_2}}$. We verify that the feature does not have any child groups during the affected interval ($F_c \interval{t_{n}}{t_{e_2}} = \emptyset$). We furthermore check that the feature has only a single name, type, and parent during the interval. This means that the original plan did not change the feature's name, type, or parent during this time. If these conditions all hold, we update the temporal feature model by clamping all the relevant intervals to $t_n$, i.e. shortening them to end at $t_n$. 

\begin{figure}
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Remove-Feature}
      {\\
        \containing{F_e}{t_n} = \set{\interval{t_{e_1}}{t_{e_2}}} \qquad
        F_c \interval{t_{n}}{t_{e_2}} = \emptyset \\
        F_n \interval{t_n}{t_{e_2}} = \set{\var{name}} \qquad
        F_t \interval{t_n}{t_{e_2}} = \set{\var{type}} \qquad
        F_p \interval{t_n}{t_{e_2}} = \set{\var{parentGoupID}} \\
        \lookup{\features{}}{\var{featureID}} = \left( F_e,\, F_n,\, F_t,\, F_p,\, F_c \right) \\
        \lookup{\groups{}}{\var{parentGroupID}} = \left( G_e,\, G_t,\, G_p,\, G_c \right)
      }
      {
        \textbf{removeFeature}\left( \var{featureID}\right) \text{ at } t_n \shove \\
        (\names{}, \features{}, \groups{}) \\
        \transition \\
        \big(\lookup{\names{}}{\var{name}} \assign \var{clampInterval}(\lookup{\names{}}{\var{name}}, t_n),\\
        \lookup{\features{}}{\var{featureID}} \assign \var{clampFeature}(\lookup{\features{}}{\var{featureID}}, t_n) ,\\
        \lookup{\groups{}}{\var{parentGroupID}} \assign \left( G_e,\, G_t,\, G_p,\, \var{clampIntervalValue}(G_c, t_n, \var{featureID})\right)\big)
      }
    \end{array}$$
  \caption{\label{rule:remove-feature}}
\end{figure}

\begin{figure}
\begin{minipage}[t]{0.5\textwidth}
  \begin{minted}[escapeinside=||]{text}
clampInterval|$\left( \map{map}, \, t_c \right)$|
  = let |$\set{\interval{t_{start}}{t_{end}}} \assign \containing{\map{map}}{t_c}$|
        |$\set{v} \assign \lookup{\map{map}}{t_c}$|
        |$\map{map}' \assign \map{map} \remove \interval{t_{start}}{t_{end}}$|
     in |$\map{map}' \interval{t_{start}}{t_c} \assign v$|
  \end{minted}
  \captionof{figure}{\label{fun:clamp-interval}}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
  \begin{minted}[escapeinside=||]{text}
clampIntervalValue|$\left( \map{map}, \, t_c ,\, v\right)$|
  = let |$\set{\interval{t_{start}}{t_{end}}} \assign \containingvalue{\map{map}}{t_c}{v}$|
        |$\map{map}' \assign \map{map} \removevalue{v} \interval{t_{start}}{t_{end}}$|
     in |$\map{map}' \interval{t_{start}}{t_c} \addassign v$|
    |$$|
  \end{minted}
  \captionof{figure}{\label{fun:clamp-interval-value}}
\end{minipage}

\begin{minipage}[t]{0.5\textwidth}
  \begin{minted}[escapeinside=||]{text}
     |$$|
clampSetInterval|$\left( \map{IS}, \, t_c \right)$|
  = let |$\set{\interval{t_{start}}{t_{end}}} \assign \containing{\map{IS}}{t_c}$|
        |$\map{IS}' \assign \map{IS} \remove \interval{t_{start}}{t_{end}}$|
     in |$\map{IS}' \cup \set{\interval{t_{start}}{t_c}}$|

     |$$|
  \end{minted}
  \captionof{figure}{\label{fun:clamp-interval-set}}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
  \begin{minted}[escapeinside=||]{text}
     |$$|
clampFeature|$\left((F_e, F_n, F_t, F_p, F_c), \, t_c \right)$|
  = |$(\var{clampSetInterval}(F_e, t_c)  $|
    |$, \var{clampInterval}(F_n, t_c)$|
    |$, \var{clampInterval}(F_t, t_c)$|
    |$, \var{clampInterval}(F_p, t_c)$|
    |$, F_c)$|
  \end{minted}
  \captionof{figure}{\label{fun:clamp-feature}}
\end{minipage}

\begin{minipage}{0.5\textwidth}
  \begin{minted}[escapeinside=||]{text}
     |$$|
clampGroup|$\left((G_e, G_t, G_p, G_c), \, t_c \right)$|
  = |$(\var{clampSetInterval}(G_e)  $|
    |$, \var{clampInterval}(G_t, t_c)$|
    |$, \var{clampInterval}(G_p, t_c)$|
    |$, G_c)$|
  \end{minted}
  \captionof{figure}{\label{fun:clamp-group}}
\end{minipage}
\end{figure}

\subsection{Remove group rule}
\label{sub:remove-group-rule}
The $\rulefont{Remove-Group}$ rule in figure \vref{rule:remove-group} describes the semantics of removing a group in a temporal feature model. The temporal scope is identified as the existence interval containing the time point for removal. In that interval, the group may not have any children, and there cannot be plans to change the type or move the group within the interval. We check the latter by looking up the type and parent feature during the interval; if the set contains only one type/parent feature then the type and parent feature do not change. 

We use the $\var{clampInterval}$ (figure \vref{fun:clamp-interval}), $\var{clampIntervalValue}$ (figure \vref{fun:clamp-interval-value}), and $\var{clampGroup}$ (figure \vref{fun:clamp-group}) helper functions to update the temporal feature model.  The $\var{clampInterval}$ function takes an interval map with non-overlapping keys and a time point $t_c$, and updates the interval key containing $t_c$ to end at $t_c$. $\var{clampIntervalValue}$ does the same, but for interval maps with overlapping keys and set values. It takes an interval map, a time point $t_c$, and a value $v$, and shortens the interval key containing $t_c$ and $v$ to end at $t_c$. $\var{clampSetInterval}$ takes an interval set with non-overlapping values and a time point $t_c$, and shortens the interval containing $t_c$. 


\begin{figure}[h]
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Remove-Group}
      {\\
        \containing{G_e}{t_n} = \set{\interval{t_{e_1}}{t_{e_2}}} \qquad
        G_c \interval{t_{n}}{t_{e_2}} = \emptyset \\
        G_t \interval{t_n}{t_{e_2}} = \set{\var{type}} \qquad
        G_p \interval{t_n}{t_{e_2}} = \set{\var{parentFeatureID}} \\
        \lookup{\groups{}}{\var{groupID}} = \left( G_e,\, G_t,\, G_p,\, G_c \right) \\
        \lookup{\features{}}{\var{parentFeatureID}} = \left( F_e,\, F_n,\, F_t,\, F_p,\, F_c \right)
      }
      {
        \textbf{removeGroup}\left( \var{groupID}\right) \text{ at } t_n \shove \\
        (\names{}, \features{}, \groups{}) \\
        \transition \\
        \big(\lookup{\names{}}{\var{name}} \assign \var{clampInterval}(\lookup{\names{}}{\var{name}}, t_n),\\
          \lookup{\features{}}{\var{parentFeatureID}} \assign \left(F_e, \, F_n, \, F_t, \, F_p, \, \var{clampIntervalValue}(F_c, t_n, \var{groupID})\right) ,\\
        \lookup{\groups{}}{\var{groupID}} \assign \var{clampGroup}(\lookup{\groups{}}{\var{groupID}}, t_n) \big)
      }
    \end{array}$$
  \caption{\label{rule:remove-group}}
\end{figure}


\subsection{Move feature rule}
\label{sub:move-feature-rule}

\todo{This is hard}

\subsection{Move group rule}
\label{sub:move-group-rule}

\todo{This is hard}

\subsection{Change feature variation type rule}
\label{sub:change-feature-variation-type-rule}
The rule in figure \vref{rule:change-feature-varation-type} shows the semantics of changing the feature variation type of the feature with ID $\var{featureID}$ at time $t_n$. The first expression above the line ($\containing{F_t}{t_n} = \set{\interval{t_{t_1}}{t_{t_2}}}$) identifies the upper bound of the temporal scope, $t_{t_2}$. This is when the feature type was originally planned to change. The next line may be hard to read, but its intent is easier to understand. It checks that all the types a parent group has \emph{while it is the parent of the feature} has a type which is compatible with the new type of the feature. If everything above the line is true, then the $\features{}$ map is updated at $\var{featureID}$ by shortening the interval key for the original type at $t_n$, and assigning the new type to the affected interval $\interval{t_n}{t_{t_2}}$. 

\begin{figure}
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Change-Feature-Variation-Type}
      {\\
        \containing{F_t}{t_n} = \set{\interval{t_{t_1}}{t_{t_2}}} % Temporal scope = [t_n, t_t_2)
        \\
        \forall \interval{t_{p_1}}{t_{p_2}}_{\in \overlapping{F_p}{t_n}{t_{t_2}}} % for all parent intervals overlapping the temporal scope
        \forall p_{\in F_p \interval{t_{p_1}}{t_{p_2}}} % for all parent groups (always exactly one) in the parent interval
        \forall t_{\in \, \var{getTypes}\left(\lookup{\groups}{p}, \clamp{\interval{t_{p_1}}{t_{p_2}}}{t_n}{t_{t_2}}\right)}
        \big(\var{compatibleTypes}(t, \var{type})\big)\\
        \lookup{\features{}}{\var{featureID}} = \left( F_e,\, F_n,\, F_t,\, F_p,\, F_c \right)
      }
      {
        \textbf{changeFeatureVariationType}\left( \var{featureID}, \var{type}\right) \text{ at } t_n \shove \\
        (\names{}, \features{}, \groups{}) \\
        \transition \\
        (\names{}, \\
        \lookup{\features{}}{\var{featureID}} \assign \left( F_e,\, F_n,\, 
        \var{clampInterval}(F_t, t_n)\interval{t_n}{t_{t_2}} \assign \var{type},\, F_p,\, F_c \right),
        \\ \groups{})
      }
    \end{array}$$
  \caption{\label{rule:change-feature-varation-type}}
\end{figure}

\begin{figure}
  \begin{minted}[escapeinside=||]{text}
getTypes|$\left((G_e, G_t, G_p, G_c), \, \interval{t_n}{t_m} \right) = G_t \interval{t_n}{t_m}$|
getTypes|$\left((F_e, F_n, F_t, F_p, F_c), \, \interval{t_n}{t_m} \right) = G_t \interval{t_n}{t_m}$|
  \end{minted}
  \caption{\label{get-types}}
\end{figure}

\subsection{Change group variation type rule}
\label{sub:change-group-variation-type-rule}
The rule in figure \vref{rule:change-group-varation-type} is similar to the \textbf{changeFeatureVariationType} rule in figure \vref{rule:change-feature-varation-type}, and shows the semantics of changing the type of a group. In a similar way to the aforementioned \textbf{changeFeatureVariationType} rule, it verifies that the types of all the child groups during the affected interval are compatible with the new group type.

\begin{figure}
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Change-Group-Variation-Type}
      {\\
        \containing{G_t}{t_n} = \set{\interval{t_{t_1}}{t_{t_2}}} % Temporal scope = [t_n, t_t_2)
        \\
        \forall \interval{t_{c_1}}{t_{c_2}}_{\in \overlapping{G_c}{t_n}{t_{t_2}}} % for all parent intervals overlapping the temporal scope
        \forall c_{\in \, \bigcup G_c \interval{t_{c_1}}{t_{c_2}}} % for all child features in the child interval
        \forall t_{\in \, \var{getTypes}\left(\lookup{\features}{c}, \clamp{\interval{t_{c_1}}{t_{c_2}}}{t_n}{t_{t_2}}\right)} % for all the types of the child features during the temporal scope
        \big(\var{compatibleTypes}(\var{type}, t)\big)\\
        \lookup{\groups{}}{\var{groupID}} = \left( G_e,\, G_t,\, G_p,\, G_c \right)
      }
      {
        \textbf{changeGroupVariationType}\left( \var{groupID}, \var{type}\right) \text{ at } t_n \shove \\
        (\names{}, \features{}, \groups{}) \\
        \transition \\
        (\names{}, \features{}, \\
        \lookup{\groups{}}{\var{groupID}} \assign \left( G_e,\, \var{clampInterval}(G_t, t_n) \interval{t_n}{t_{t_2}} \assign \var{type},\, G_p,\, G_c \right))
      }
    \end{array}$$
  \caption{\label{rule:change-group-varation-type}}
\end{figure}

\subsection{Change feature name}
\label{sub:change-feature-name}

The semantics of changing the name of a feature are shown in the \rulefont{Change-Feature-Name} rule in figure \vref{rule:change-feature-name}. The old name and the next planned name change are identified on the first line ($\lookup{F_n}{t_n} = \set{\var{oldName}}$ and $\containing{F_n}{t_n} = \set{\interval{t_{n_1}}{t_{n_2}}}$ respectively). Since the name must not be in use during the temporal scope, we verify that looking up the new name in the $\names{}$ map returns an empty set. The $\names{}$ map is updated by shortening the interval for the old name to end at $t_n$, and assigning the feature ID to the new name during the temporal scope. Furthermore, the $\features{}$ map is updated at the feature ID, shortening the interval for the old name and assigning the new name to the temporal scope. 

\begin{figure}
    \renewcommand{\arraystretch}{1.1}
    \sossize$$\begin{array}{c}
      \ntyperule{Change-Feature-Name}
      {\\
        \lookup{F_n}{t_n} = \set{\var{oldName}} \qquad
        \containing{F_n}{t_n} = \set{\interval{t_{n_1}}{t_{n_2}}} \\
        \lookup{\names{}}{\var{name}}\interval{t_n}{t_{n_2}} = \emptyset \\
        \lookup{\features{}}{\var{featureID}} = \left( F_e,\, F_n,\, F_t,\, F_p,\, F_c \right)
      }
      {
        \textbf{changeFeatureName}\left( \var{featureID}, \var{name}\right) \text{ at } t_n \shove \\
        (\names{}, \features{}, \groups{}) \\
        \transition \\
        (\lookup{\left(\lookup{\names{}}{\var{name}}\interval{t_n}{t_{n_2}} \assign \var{featureID}\right)}{\var{oldName}} \assign \var{clampInterval}(\lookup{\names}{\var{oldName}}, t_n), \\
        \lookup{\features{}}{\var{featureID}} \assign \left( F_e,\, \var{clampInterval}(F_n, t_n)\interval{t_n}{t_{n_2}} \assign \var{name},\, F_t,\, F_p,\, F_c \right), \\
        \groups{})
      }
    \end{array}$$
  \caption{\label{rule:change-feature-name}}
\end{figure}
