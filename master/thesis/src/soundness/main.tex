\chapter{Soundness}
\label{cha:soundness}
\todo{and completeness? The operations in themselves are not complete, in the sense that there is not a one-to-one correspondence between the operations defined on temporal feature models (temporal operations) and the operations defined on feature models (model operations). However, the temporal operations are more restricted than the model operations, and any valid change within that subset to an evolution plan would be accepted by the rules. Should I try to prove completeness as well?}

\todo{Root feature requirements}

We use an inductive proof structure to prove soundness and modularity for the rule system (section \vref{sec:sos-rules}). The base case is a proof by construction, in which we define a sound temporal feature model. Using the induction hypothesis that the initial model is sound, we prove that each rule preserves soundness and operates within the previously defined scope (section \vref{sec:define-the-scope}).

\section{Soundness for temporal feature models}
\label{sec:soundness-for-temporal-feature-models}
\todo{Argue that the rules are \emph{enough} to preserve soundness.}
\todo{Show what needs to be proved for an initial model. ``correct by construction". In a well-formed structure. Lemma: What is a sound structure. Soundness theorem: Preserves soundness, using the lemma.}
\todo{Proof for each rule should be lemma, and the whole system is a theorem or something:). Remember to number the lemmas}
\todo{The structure of the proof should be introduced first}
\todo{In the theorem, emphasize the structure of the proof (inductive)}
\todo{Between the proofs, add some text; how to read the proof, how to understand etc. Also give context (how the lemmas are used later)}

The temporal feature model can be viewed as a sequence of feature models associated with time points. A feature model has strict structural requirements, and the definition of a paradox is a feature model that violates these requirements. In this context, soundness means that if a rule accepts a modification, realising the modified plan results in a sequence of feature models where each is structurally sound. The soundness analysis in this chapter assumes that the original plan is sound; i.e. all resulting feature models fulfil the structural requirements. 

We must first define what it means for a temporal feature model to be sound. Essentially, it means that if we converted the temporal feature model into a sequence of time points associated with feature models, each feature model would be sound.

According to \cite{art:consistency-preserving-evolution-planning}, the structural requirements (well-formedness rules) are 
\begin{enumerate}[\itbf{WF\arabic*}, itemsep=0mm]
   \item A feature model has exactly one root feature.
   \item The root feature must be mandatory.
   \item Each feature has exactly one unique name, variation type and (potentially empty) collection of subgroups.
   \item Features are organized in groups that have exactly one variation type.
   \item Each feature, except for the root feature, must be part of exactly one group.
   \item Each group must have exactly one parent feature.
   \item Groups with types \xortype{} or \ortype{} must not contain \mandatory{} features.
\end{enumerate}

Furthermore, a feature model is a tree structure and must not contain cycles. There is an additional requirement that groups with types \xortype{} or \ortype{} must contain at least two child features, but this is not taken into account in this thesis.

These requirements can be translated into rules for temporal feature models $(\names, \features, \groups)$. We assume that the first time point in the plan is $t_0$.

\begin{enumerate}[\itbf{TFMWF\arabic*}, itemsep=0mm]
   \item A temporal feature model has exactly one root feature. We assume that the root ID is $\var{rootID}$, and that $\lookup{\features}{\var{rootID}} = \featurevar{R}$. This also means that $R_e=\set{\interval{t_0}{\forever}}$ \textemdash{} the root always exists, and that $R_p = \emptyset$ \textemdash{} the root never has a parent group.
\item The root feature must be mandatory. This means that $$R_t  = \set{\intervalmapping{t_0}{\forever}{\mandatory}}$$ where $R_t$ is the types map of the root feature. 
\item At any time $t_n \geq t_0$, each feature has exactly one unique name, variation type and (potentially empty) collection of subgroups. Given a feature ID $\var{featureID}$, this means that if $\lookup{\features}{\var{featureID}} = \feature$ and $t_n \inn F_e$ , then
   \begin{enumerate}[(i)]
      \item $\lookup{F_n}{t_n} = \set{\var{name}}$ \textemdash{} the feature has exactly one name,
      \item $\lookup{\lookup{\names}{\var{name}}}{t_n} = \set{\var{featureID}}$ \textemdash{} the name is unique \emph{at the time point $t_n$},
      \item $\lookup{F_t}{t_n} = \set{\var{type}} \text{ with } \var{type} \in \set{\mandatory, \optional}$ \textemdash{} the feature has exactly one type, and
      \item $\lookup{F_c}{t_n} = C$, such that $\bigcup C$ is a set of the group IDs, and if $\var{groupID} \in \bigcup C$ and $\lookup{\groups}{\var{groupID}} = \group{}$, then $\lookup{G_p}{t_n} = \set{\var{featureID}}$ \textemdash{} if a group is listed as a subgroup of a feature, then the feature is listed as the parent of the group at the same time.
   \end{enumerate}
   \item At any time $t_n \geq t_0$, each group has exactly one variation type. Given a group ID $\var{groupID}$, this means that if $\lookup{\groups}{\var{groupID}} = \group$ and $t_n \inn G_e$, then $\lookup{G_t}{t_n} = \set{\var{type}}$ for $\var{type} \in \set{\andtype, \ortype, \xortype}$.
   \item At any time $t_n \geq t_0$, each feature, except for the root feature, must be part of exactly one group. Formally, given a feature ID $\var{featureID} \neq \var{rootID}$, if $\lookup{\features}{\var{featureID}} = \feature$, and $t_n \inn F_e$, then $\lookup{F_p}{t_n} = \set{\var{groupID}}$ with $\lookup{\groups}{\var{groupID}} = \group$, $t_n \inn G_e$, and $\var{featureID} \in \bigcup \lookup{G_c}{t_n}$. 
   \item At any time $t_n \geq t_0$, each group must have exactly one parent feature. Formally, given a group ID $\var{groupID}$, if $\lookup{\groups}{\var{groupID}} = \group$ and $t_n \inn G_e$, then $\lookup{G_p}{t_n} = \set{\var{featureID}}$, and $\lookup{\features}{\var{featureID}} = \feature$ with $\var{groupID} \in \bigcup \lookup{F_c}{t_n}$.
   \item At any time $t_n$, a group with types \xortype{} or \ortype{} must not contain \mandatory{} features. Formally, given a group ID $\var{groupID}$ with $\lookup{\groups}{\var{groupID}} = \group$, if $\lookup{F_t}{t_n} \set{\var{type}}$ with $\var{type} \in \set{\xortype{}, \ortype{}}$, and if $\var{featureID} \in \bigcup \lookup{F_c}{t_n}$ and $\lookup{\features}{\var{featureID}} = \feature$, then $\lookup{F_t}{t_n} = \set{\optional}$.
\end{enumerate}

We must add two additional requirements:
\begin{enumerate}[itemsep=0mm]
   \item[\itbf{TFMWF8}] For a feature with ID $\var{featureID}$ such that $\lookup{\features}{\var{featureID}} = \feature$, if $t_n \notinn F_e$, then $\lookup{F_n}{t_n} = \lookup{F_t}{t_n} = \lookup{F_p}{t_n} = \lookup{F_c}{t_n} = \emptyset$, and for all keys $\var{name}$ in $\names$, $\var{featureID} \notin \lookup{\lookup{\names}{\var{name}}}{t_n}$ \textemdash{} no name belongs to the feature. Similarly, for a group with ID $\var{groupID}$ such that $\lookup{\groups}{\var{groupID}} = \group$, if $t_n \notinn G_e$, then $\lookup{G_t}{t_n} = \lookup{G_p}{t_n} = \lookup{G_c}{t_n} = \emptyset$. In other words, a feature or a group which does not exist cannot have a name, a type, a parent, or a child.
   \item[\itbf{TFMWF9}] The temporal feature model contains no cycles, which means that at any time point $t_n \geq t_0$, for any feature or group that exists at $t_n$, if we follow the parent chain upwards, we never encounter the same feature or group twice. In other words, no feature or group is its own ancestor.
\end{enumerate}

Together, these requirements form the basis of the soundness proofs. We assume that the original plan is sound, so each of these requirements is assumed to be true for the original temporal feature model. Furthermore, we prove that the requirements must still hold for the updated model if the rule can be applied.

\paragraph{Soundness of the rules}
In the following sections, we prove that each rule is sound, and conclude that the system is sound.

For each rule, the proof for soundness includes three parts: 
\begin{enumerate}[(i)]
   \item proving that the rule operates strictly within the previously defined temporal and spatial scopes (section \vref{sec:define-the-scope}), 
   \item that the rule preserves well-formedness, as defined in the above requirements \itbf{TFMWF1-9}, and
   \item that the rule updates the model correctly, preserving soundness as well as respecting the semantics of the operation.
\end{enumerate}

\section{Soundness of the Add feature rule}
\label{sec:soundness-of-the-add-feature-rule}

\todo{Use a proof environment that clearly separate definitions from proofs. The proofs should contain syntactic correctness, not semantic (that part is moved out of the proof)}

See figure \vref{rule:add-feature} for the \rulefont{Add-Feature} rule.
Let 
\begin{equation*}
   \begin{split}
      \textbf{addFeature}(\var{featureID}, \var{name}, \var{type}, \var{parentGroupID})\text{ at }\interval{t_n}{t_m}
      \shove \\
   (\names{}, \features{}, \groups{})
\end{split}
\end{equation*}
be the initial state. Recall that this operation adds the feature with ID \var{featureID} to the temporal feature model $(\names{}, \features{}, \groups{})$ from $t_n$ to $t_m$. We assume that $(\names{}, \features{}, \groups{})$ is well-formed, as defined in \itbf{TFMWF1-9}.

\todo{Show that the feature model outside the scope is unchanged}

\paragraph{Scope}

Recall from section \vref{sec:define-the-scope} that the temporal scope of this operation is $\interval{t_n}{t_m}$, and the spatial scope is the feature itself, the parent group and the name. 

In the rule, we look up only the feature ID, the parent group ID, and the name, and update only the name, feature, and parent group. Thus, the rule operates within the spatial scope of the operation. Furthermore, the only interval looked up in the interval maps and sets of the model is $\interval{t_n}{t_m}$, which is exactly the temporal scope of the rule. Hence the rule operates strictly within the temporal and spatial scopes of the operation.
\\

\begin{lemma}
   The \rulefont{Add-Feature} rule operates strictly within the scope of the \textbf{addFeature} operation.
   \label{lemma:add-feature-scope}
\end{lemma}


\paragraph{Preserving well-formedness}

If the rule is applied, the well-formedness requirements must hold for the updated feature model. 

Since the rule checks that the feature does not already exist during the temporal scope, it is impossible that $\var{featureID} = \var{rootID}$. Thus the rule does not affect the root feature, and \itbf{TFMWF1} and \itbf{TFMWF2} hold for the updated temporal feature model.

Because we assume that \itbf{TFMWF8} holds for the original model, and the feature does not exist during $\interval{t_n}{t_m}$, the feature has no name, type, or subgroups in the original plan. When we add the feature to the feature model using \var{setFeatureAttributes}, we give the feature exactly one name and one type during the temporal scope, and the set of child groups is empty. The temporal scope is also added to the feature's existence set, so only the new feature has the ID $\var{featureID}$ during the temporal scope. To link the feature ID to the name, the rule sets the feature ID as the value at key $\var{name}$ in the $\names{}$ map during the temporal scope, so the name is unique during the temporal scope.
Consequently, \itbf{TFMWF3} holds.

The rule does not modify the parent group's variation type, so \itbf{TFMWF4} is preserved in the modified temporal feature model.

Similarly to the argument for \itbf{TFMWF3}, the parent group ID is uniquely defined for the feature in \var{setFeatureAttributes}, and \var{featureID} is added to the parent group's set of child features, so the new feature is part of exactly one group. Since we do not remove any other feature IDs from the parent group's set of features, and as we already established that the new feature is not the root feature, \itbf{TFMWF5} is preserved.

The new feature does not have any subgroups during the temporal scope, and we do not modify the parent group's parent feature. Under the assumption that \itbf{TFMWF6} holds in the original model, it still holds after applying the \rulefont{Add-Feature} rule.

The rule verifies that all of the parent group's types are compatible with the added feature's type during the temporal scope, so \itbf{TFMWF7} holds after applying the rule.

Since the rule adds the temporal scope to the new feature's existence table, and since the parent group exists in the original plan, \itbf{TFMWF8} is preserved after the rule is applied.

It is furthermore impossible that adding this feature creates a cycle in the modified model. The new feature has no subgroups, so it cannot be part of a cycle. Because of the assumption that \itbf{TFMWF9} holds in the original plan, and applying the rule does not introduce a cycle, this requirement still holds. 

As the rule operates within the scope (lemma \vref{lemma:add-feature-scope}), it does not affect any other part of the plan.

We conclude that the \rulefont{Add-Feature} rule preserves well-formedness for the temporal feature model, according to well-formedness rules \itbf{TFMWF1-9}. 
\\
\begin{lemma}
   The \rulefont{{Add-Feature}} rule preserves well-formedness of the temporal feature model.
   \label{lemma:add-feature-well-formed}
\end{lemma}

\todo{Mention that the scope part ensures that no other part of the plan is affected}
\paragraph{Correctness of model modification}

The operation is intended to add the feature with ID \var{featureID} to the temporal feature model during the interval $\interval{t_n}{t_m}$. 

After adding the feature to the temporal feature model, looking up the name $\var{name}$ in the $\names{}$ map at interval key $\interval{t_n}{t_m}$ should give the value $\var{featureID}$. Indeed, since the $\names{}$ map is updated thus:
\[
   \lookup{\lookup{\names}{\var{name}}}{\interval{t_n}{t_m}} \assign \var{featureID}
\]
, then due to the semantics of map assignment (definition \vref{def:map}), and lookup in interval maps (definition \vref{def:interval-map}),
\[
   \lookup{\lookup{\names}{\var{name}}}{\interval{t_n}{t_m}} = \set{\var{featureID}}
\]
will hold.

Similarly, if we wish to lookup information about the feature during the interval $\interval{t_n}{t_m}$ in the modified model, the results should match the information in the operation. The rule assigns 
\begin{equation*}
   \begin{split}
   \var{setFeatureAttributes}(\lookup{\features{}}{\var{featureID}}, \interval{t_n}{t_m}, \var{name}, \var{type}, \\
   \var{parentGroupID})
   \end{split}
\end{equation*}

to $\lookup{\features}{\var{featureID}}$. 

According to the semantics of assignment (section \vref{sub:maps}) and $\var{setFeatureAttributes}$ (figure \vref{fun:set-feature-attributes}), and given that $\lookup{\features}{\var{featureID}} = \feature$, then 
\begin{align}
   \interval{t_n}{t_m} &\in F_e && \text{the feature exists} \tag{1} \label{add-feature1}\\
   \lookup{F_n}{\interval{t_n}{t_m}} &= \set{\var{name}} && \text{the feature has the expected name} \tag{2} \label{add-feature2}\\
   \lookup{F_t}{\interval{t_n}{t_m}} &= \set{\var{type}}  && \text{the feature has the expected type} \tag{3} \label{add-feature3}\\
   \lookup{F_p}{\interval{t_n}{t_m}} &= \set{\var{parentGroupID}}  && \text{the feature has the expected parent group} \tag{4} \label{add-feature4}\\
   \lookup{F_c}{\interval{t_n}{t_m}} &= \emptyset && \text{the feature has no children} \tag{5} \label{add-feature5}
\end{align}

Statement (\ref{add-feature1}) holds due to the line $F_e \cup \interval{t_n}{t_m}$ in $\var{setFeatureAttributes}$. The next four hold due to both premises in the rule and modifications in the function. Due to the premise $\interval{t_n}{t_m} \not \innr F_e$, which means that the feature does not previously exist at any point during the interval, and since \itbf{TFMWF8} is assumed to hold for the original model, the original feature does not have a name, type, parent group or child groups during the interval. In the function $\var{setFeatureAttributes}$, the name is added ($\lookup{F_n}{\interval{t_{start}}{t_{end}}} \assign \var{name}$), and so is the type ($\lookup{F_t}{\interval{t_{start}}{t_{end}}} \assign \var{type}$) and the parent group ($\lookup{F_t}{\interval{t_{start}}{t_{end}}} \assign \var{parentGroupID}$). The child groups are not modified, and so (\ref{add-feature5}) holds.

The child features of the group must also be updated according to the semantics of the operation. After applying the rule, given that $\lookup{\groups}{\var{parentGroupID}} = \group{}$, 
\[
   \var{featureID} \in \bigcup \lookup{G_c}{\interval{t_n}{t_m}}
\]
, meaning that the feature is in the parent group's set of child features in the updated model. This holds because $\lookup{\groups}{\var{parentGroupID}}$ is assigned $\var{addChildFeature}(\lookup{\groups}{\var{parentGroupID}}, \interval{t_n}{t_m}, \var{featureID})$ (see figure \vref{fun:add-child-feature}), which modifies $G_c$ by adding $\var{featureID}$ to the set of child features at interval key $\interval{t_n}{t_m}$.
\\

\begin{lemma}
   The \rulefont{Add-Feature} rule updates the temporal feature model according to the semantics of the \textbf{addFeature} operation.
   \label{lemma:add-feature-mod}
\end{lemma}

\section{Soundness for the Add group rule}
\label{sec:soundness-for-the-add-group-rule}

See figure \vref{rule:add-group} for the \rulefont{Add-Group} rule. 
Let 
\begin{equation*}
   \begin{split}
      \textbf{addGroup}(\var{groupID}, \var{type}, \var{parentFeatureID})\text{ at }\interval{t_n}{t_m}
      \shove \\
   (\names{}, \features{}, \groups{})
\end{split}
\end{equation*}
be the initial state. Recall that this operation adds the group with ID \var{groupID} to the temporal feature model $(\names{}, \features{}, \groups{})$ from $t_n$ to $t_m$. 

\paragraph{Scope}

Recall from section \vref{sec:define-the-scope} that the temporal scope of this operation is $\interval{t_n}{t_m}$, and the spatial scope is the group itself and the parent feature.

In the premise of the rule, only $\var{groupID}$ and $\var{parentFeatureID}$ are looked up in the temporal feature model. Consequently, the premise stays within the spatial scope of the rule. In the conclusion of the rule, $\features{}$ are assigned to and looked up at $\var{parentFeatureID}$, and $\groups{}$ at $\var{groupID}$. The helper functions $\var{addChildGroup}$ (figure \vref{fun:add-child-group}) and $\var{setGroupAttributes}$ (figure \vref{fun:set-group-attributes}) do not take the temporal feature model as argument, and so only affects the parent feature and the group itself, respectively.

As for the temporal scope, the only interval looked up in the rule is $\interval{t_n}{t_m}$. Hence the rule operates only within the defined temporal scope.
\\

\begin{lemma}
   The \rulefont{Add-Group} rule operates strictly within the scope of the \textbf{addGroup} operation.
   \label{lemma:add-group-scope}
\end{lemma}

\paragraph{Preserving well-formedness}

If the \rulefont{Add-Group} rule is applied, the resulting temporal feature model must be well-formed according to to the well-formedness rules \itbf{TFMWF1-9}. 

The rule does not change the root feature's existence or type, so it does not violate \itbf{TFMWF1} or \itbf{TFMWF2}. The $\names{}$ map is left unchanged, and the only change made to a feature is to the parent feature, adding $\var{groupID}$ to the set of child groups at $\interval{t_n}{t_m}$. The only feature modified is the parent feature, and only in its child groups map $F_c$. Since $\var{parentFeatureID}$ is assigned to the group's parent feature table $F_p$ at the same key $\interval{t_n}{t_m}$, \itbf{TFMWF3} holds.

Given that \itbf{TFMWF8} holds in the original model, and as the rule premise makes certain that the group does not already exist during the interval $\interval{t_n}{t_m}$, the group does not have any types, parent features, or child features during the interval. When the rule is applied, the group is given exactly one type and parent feature, and $\interval{t_n}{t_m}$ is added to its existence set. Thus \itbf{TFMWF4}, \itbf{TFMWF6}, and \itbf{TFMWF8} hold. 

As for \itbf{TFMWF5}, this requirement holds trivially given that it holds in the original model. No feature is added or removed from any group in the \itbf{Add-Group} rule, so this condition is not affected and thus still holds.

Similarly, \itbf{TFMWF7} will hold in the altered model given that it holds in the original one, since the new group does not contain any features during the temporal scope. For the same reason, the rule does not create a cycle, and so \itbf{TFMWF9} is true for the altered model.
\\

\begin{lemma}
   The \rulefont{Add-Group} rule preserves well-formedness of the temporal feature model.
   \label{lemma:add-group-well-formed}
\end{lemma}

\paragraph{Correctness of model modification}

The operation is intended to add the group with ID $\var{groupID}$ to the temporal feature model during the interval $\interval{t_n}{t_m}$. Since groups have no names, this operation should not affect the $\names{}$ map. Indeed, the rule reflects this, as the map is not changed in the transition.

However, the operation does naturally add information to the $\groups{}$ map, assigning
\begin{equation*}
   \var{setGroupAttributes}( \lookup{\groups{}}{\var{groupID}}, \var{type}, 
   \var{parentFeatureID} )
\end{equation*}
to $\lookup{\groups}{\var{groupID}}$.

Looking up the added group's ID in the modified model should return the information we put in the operation, and given $\lookup{\groups}{\var{groupID}} = \group$, the following statements hold:
\begin{align}
   \interval{t_n}{t_m} &\in G_e && \text{the group exists} \tag{1} \label{add-group1}\\
   \lookup{G_t}{\interval{t_n}{t_m}} &= \set{\var{type}}  && \text{the group has the expected type} \tag{2} \label{add-group2}\\
   \lookup{G_p}{\interval{t_n}{t_m}} &= \set{\var{parentGroupID}}  && \text{the group has the expected parent feature} \tag{3} \label{add-group3}\\
   \lookup{G_c}{\interval{t_n}{t_m}} &= \emptyset && \text{the group has no children} \tag{4} \label{add-group4}
\end{align}

Statement (\ref{add-group1}) holds due to the line $G_e \cup \interval{t_n}{t_m}$ in $\var{setGroupAttributes}$ (figure \vref{fun:set-group-attributes}). Given the semantics of assignment, also statement (\ref{add-group2}) and (\ref{add-group3}) hold, as the type and parent feature ID are assigned to $\lookup{G_t}{\interval{t_n}{t_m}}$ and $\lookup{G_p}{\interval{t_n}{t_m}}$ respectively in $\var{setGroupAttributes}$. Given that \itbf{TFMWF8} is true for the original model, and since $\var{setGroupAttributes}$ does not modify $G_c$, statement (\ref{add-group4}) is also true.

Furthermore, we would expect the group to be listed as a child group of the parent feature in the modified model, so given that $\lookup{\features{}}{\var{parentFeatureID}} = \feature$, then
\begin{equation*}
   \var{groupID} \in \bigcup \lookup{F_p}{\interval{t_n}{t_m}}
\end{equation*}
In the \rulefont{Add-Group} rule, $\var{addChildGroup}(\lookup{\features}{\var{parentFeatureID}}, \interval{t_n}{t_m}, \var{groupID}$ is assigned to $\lookup{\features}{\var{parentFeatureID}}$. The function $\var{addChildGroup}$ (figure \vref{fun:add-child-group}) adds $\var{groupID}$ to the set of child features at key $\interval{t_n}{t_m}$, so according to the semantics of $\addassign$, it is indeed true that the group is in the parent feature's set of child group in the temporal scope.
\\

\begin{lemma}
   The \rulefont{Add-Group} rule updates the temporal feature model according to the semantics of the \textbf{addGroup} operation.
   \label{lemma:add-group-mod}
\end{lemma}

\section{Soundness of the Remove feature rule}
\label{sec:soundness-of-the-remove-feature-rule}

See figure \vref{rule:remove-feature} for the \rulefont{Remove-Feature} rule. 
Let 
\begin{equation*}
   \begin{split}
      \textbf{removeFeature}(\var{featureID})\text{ at } t_n
      \shove \\
   (\names{}, \features{}, \groups{})
\end{split}
\end{equation*}
be the initial state. Recall that this operation removes the feature with ID \var{featureID} from the temporal feature model $(\names{}, \features{}, \groups{})$ at $t_n$. Furthermore, let $\lookup{\features}{\var{featureID}} = \feature$, and $\interval{t_i}{t_j} \in F_e$, with $t_i \leq t_n < t_j$. This means that the original plan added the feature at time $t_i$ and removed it at $t_j$, with the possibility that $t_j = \forever$. In the latter case, there was no plan to remove the feature originally.

\paragraph{Scope}
As defined in section \vref{sec:define-the-scope}, the \textbf{removeFeature} rule's temporal scope is $\interval{t_n}{t_k}$, where $t_k$ is the time point in which the feature was originally planned to be removed. We can see from the description above that $t_k = t_j$; the end point in the feature's existence set containing $t_n$. We then have that the scope is defined as $\interval{t_n}{t_j}$. In the rule, we find the interval $\interval{t_i}{t_j}$ by looking up
\begin{equation*}
   \containing{F_e}{t_n} = \set{\interval{t_{e_1}}{t_{e_2}}}
\end{equation*}
   According to the semantics of $\containing{\map{IS}}{t_n}$, it is true then that $\interval{t_i}{t_j} = \interval{t_{e_1}}{t_{e_2}}$, and so the temporal scope of the rule is $\interval{t_n}{t_{e_2}} = \interval{t_n}{t_j}$. Clearly, all time points looked up in the premise of the rule are contained within this interval, but the conclusion requires further examination. The $\names{}$ map is assigned $\var{clampInterval}(\lookup{\names}{\var{name}}, t_n)$ at key $\var{name}$. In $\var{clampInterval}$ (figure \vref{fun:clamp-interval}), the interval $\interval{t_{n_1}}{t_{n_2}}$ containing $t_n$ in $\lookup{\names}{\var{name}}$ is looked up and shortened to end at $t_n$ instead of $t_{n_2}$. This modification stays within the scope of the temporal feature model, since the interval affected here is $\interval{t_n}{t_{n_2}}$, and necessarily, $t_{n_2} \leq t_j$, since the feature cannot possibly have a name after it is removed according to \itbf{TFMWF8}. 

   The $\features{}$ map is modified at key $\var{featureID}$ by assigning $\var{clampFeature}(\lookup{\features}{\var{featureID}}, t_n)$. In $\var{clampFeature}$ (figure \vref{fun:clamp-feature}), the intervals of the feature's name, type, and parent are clamped to end at $t_n$. These modifications, too, stay within the temporal scope, for the reason explained in the above paragraph. The existence interval is clamped in a similar way, and so stays within the temporal scope as well.

   Also, the $\groups{}$ map is assigned $\var{removeFeatureAt}(\lookup{\groups}{\var{parentGroupID}}, \var{featureID}, t_n)$ at key $\var{parentGroupID}$. This helper function (figure \vref{fun:remove-feature-at}) modifies the parent group's table of subfeatures by calling $\var{clampIntervalValue}(G_c, t_c, \var{featureID})$, which behaves similarly to $\var{clampInterval}$ by clamping the interval containing $t_n$. The difference is that it removes only $\var{featureID}$ from the set of child groups, and adds the feature to the set of subfeatures at the shortened interval. We conclude that this modification, too, happens within the temporal scope of the operation, as looking up any time point outside of the temporal scope will return the same results as the original plan.

   Recall that the spatial scope of the rule is the feature itself, its parent group, and its subtree. The premise
\begin{equation*}
   \lookup{F_c}{\interval{t_n}{t_{e_2}}} = \emptyset
\end{equation*}
   ensures that the operation is not applied unless the feature's subtree is empty. The only features and groups looked up is the feature itself and its parent group. Thus, the rule stays within the spatial scope.

\begin{lemma}
   The $\rulefont{Remove-Feature}$ rule operates strictly within the scope of the \textbf{removeFeature} operation.
\end{lemma}

\paragraph{Preserving well-formedness}

The \rulefont{Remove-Feature} rule contains the premise
\begin{equation*}
   \lookup{F_p}{\interval{t_n}{t_{e_2}}} = \set{\var{parentGroupID}}
\end{equation*}
, ensuring that the feature has \emph{exactly} one parent group during the temporal scope of the rule. Under the assumption that \itbf{TFMWF1} holds in the original model, the feature being removed cannot be the root feature, since the root has no parent group. Furthermore, it means that the feature does not move during the temporal scope, which would be a conflict. Therefore, both \itbf{TFMWF1} and \itbf{TFMWF2} hold in the modified model.

For any time point $t_n$ in the temporal scope of the rule, $t_n \notinn F_e$, so \itbf{TFMWF3} holds trivially.

