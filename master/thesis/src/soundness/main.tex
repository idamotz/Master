\chapter{Soundness}
\label{cha:soundness}
\todo{and completeness? The operations in themselves are not complete, in the sense that there is not a one-to-one correspondence between the operations defined on temporal feature models (temporal operations) and the operations defined on feature models (model operations). However, the temporal operations are more restricted than the model operations, and any valid change within that subset to an evolution plan would be accepted by the rules. Should I try to prove completeness as well?}

\todo{Root feature requirements}

We use an inductive proof structure to prove soundness and modularity for the rule system (section \vref{sec:sos-rules}). The base case is a proof by construction, in which we define a sound temporal feature model. Using the induction hypothesis that the initial model is sound, we prove that each rule preserves soundness and operates within the previously defined scope (section \vref{sec:define-the-scope}).

\section{Soundness for temporal feature models}
\label{sec:soundness-for-temporal-feature-models}
\todo{Argue that the rules are \emph{enough} to preserve soundness.}
\todo{Show what needs to be proved for an initial model. ``correct by construction". In a well-formed structure. Lemma: What is a sound structure. Soundness theorem: Preserves soundness, using the lemma.}
\todo{Proof for each rule should be lemma, and the whole system is a theorem or something:). Remember to number the lemmas}
\todo{The structure of the proof should be introduced first}
\todo{In the theorem, emphasize the structure of the proof (inductive)}
\todo{Between the proofs, add some text; how to read the proof, how to understand etc. Also give context (how the lemmas are used later)}

The temporal feature model can be viewed as a sequence of feature models associated with time points. A feature model has strict structural requirements, and the definition of a paradox is a feature model that violates these requirements. In this context, soundness means that if a rule accepts a modification, realising the modified plan results in a sequence of feature models where each is structurally sound. The soundness analysis in this chapter assumes that the original plan is sound; i.e. all resulting feature models fulfil the structural requirements. 

We must first define what it means for a temporal feature model to be sound. Essentially, it means that if we converted the temporal feature model into a sequence of time points associated with feature models, each feature model would be sound.

According to \cite{art:consistency-preserving-evolution-planning}, the structural requirements (well-formedness rules) are 
\begin{enumerate}[\itbf{WF\arabic*}, itemsep=0mm]
   \item A feature model has exactly one root feature.
   \item The root feature must be mandatory.
   \item Each feature has exactly one unique name, variation type and (potentially empty) collection of subgroups.
   \item Features are organized in groups that have exactly one variation type.
   \item Each feature, except for the root feature, must be part of exactly one group.
   \item Each group must have exactly one parent feature.
   \item Groups with types \xortype{} or \ortype{} must not contain \mandatory{} features.
\end{enumerate}

Furthermore, a feature model is a tree structure and must not contain cycles. There is an additional requirement that groups with types \xortype{} or \ortype{} must contain at least two child features, but this is not taken into account in this thesis.

These requirements can be translated into rules for temporal feature models $(\names, \features, \groups)$. We assume that the first time point in the plan is $t_0$.

\begin{enumerate}[\itbf{TFMWF\arabic*}, itemsep=0mm]
   \item A temporal feature model has exactly one root feature. We assume that the root ID is $\var{rootID}$, and that $\lookup{\features}{\var{rootID}} = \featurevar{R}$. This also means that $R_e=\set{\interval{t_0}{\forever}}$ \textemdash{} the root always exists, and that $R_p = \emptyset$ \textemdash{} the root never has a parent group.
\item The root feature must be mandatory. This means that $$R_t  = \set{\intervalmapping{t_0}{\forever}{\mandatory}}$$ where $R_t$ is the types map of the root feature. 
\item At any time $t_n \geq t_0$, each feature has exactly one unique name, variation type and (potentially empty) collection of subgroups. Given a feature ID $\var{featureID}$, this means that if $\lookup{\features}{\var{featureID}} = \feature$ and $t_n \inn F_e$ , then
   \begin{enumerate}[(i)]
      \item $\lookup{F_n}{t_n} = \set{\var{name}}$ \textemdash{} the feature has exactly one name,
      \item $\lookup{\lookup{\names}{\var{name}}}{t_n} = \set{\var{featureID}}$ \textemdash{} the name is unique \emph{at the time point $t_n$},
      \item $\lookup{F_t}{t_n} = \set{\var{type}} \text{ with } \var{type} \in \set{\mandatory, \optional}$ \textemdash{} the feature has exactly one type, and
      \item $\lookup{F_c}{t_n} = C$, such that $\bigcup C$ is a set of the group IDs, and if $\var{groupID} \in \bigcup C$ and $\lookup{\groups}{\var{groupID}} = \group{}$, then $\lookup{G_p}{t_n} = \set{\var{featureID}}$ \textemdash{} if a group is listed as a subgroup of a feature, then the feature is listed as the parent of the group at the same time.
   \end{enumerate}
   \item At any time $t_n \geq t_0$, each group has exactly one variation type. Given a group ID $\var{groupID}$, this means that if $\lookup{\groups}{\var{groupID}} = \group$ and $t_n \inn G_e$, then $\lookup{G_t}{t_n} = \set{\var{type}}$ for $\var{type} \in \set{\andtype, \ortype, \xortype}$.
   \item At any time $t_n \geq t_0$, each feature, except for the root feature, must be part of exactly one group. Formally, given a feature ID $\var{featureID} \neq \var{rootID}$, if $\lookup{\features}{\var{featureID}} = \feature$, and $t_n \inn F_e$, then $\lookup{F_p}{t_n} = \set{\var{groupID}}$ with $\lookup{\groups}{\var{groupID}} = \group$, $t_n \inn G_e$, and $\var{featureID} \in \bigcup \lookup{G_c}{t_n}$. 
   \item At any time $t_n \geq t_0$, each group must have exactly one parent feature. Formally, given a group ID $\var{groupID}$, if $\lookup{\groups}{\var{groupID}} = \group$ and $t_n \inn G_e$, then $\lookup{G_p}{t_n} = \set{\var{featureID}}$, and $\lookup{\features}{\var{featureID}} = \feature$ with $\var{groupID} \in \bigcup \lookup{F_c}{t_n}$.
   \item At any time $t_n$, a group with types \xortype{} or \ortype{} must not contain \mandatory{} features. Formally, given a group ID $\var{groupID}$ with $\lookup{\groups}{\var{groupID}} = \group$, if $\lookup{F_t}{t_n} \set{\var{type}}$ with $\var{type} \in \set{\xortype{}, \ortype{}}$, and if $\var{featureID} \in \bigcup \lookup{F_c}{t_n}$ and $\lookup{\features}{\var{featureID}} = \feature$, then $\lookup{F_t}{t_n} = \set{\optional}$.
\end{enumerate}

We must add two additional requirements:
\begin{enumerate}[itemsep=0mm]
   \item[\itbf{TFMWF8}] For a feature with ID $\var{featureID}$ such that $\lookup{\features}{\var{featureID}} = \feature$, if $t_n \notinn F_e$, then $\lookup{F_n}{t_n} = \lookup{F_t}{t_n} = \lookup{F_p}{t_n} = \lookup{F_c}{t_n} = \emptyset$, and for all keys $\var{name}$ in $\names$, $\var{featureID} \notin \lookup{\lookup{\names}{\var{name}}}{t_n}$ \textemdash{} no name belongs to the feature. Similarly, for a group with ID $\var{groupID}$ such that $\lookup{\groups}{\var{groupID}} = \group$, if $t_n \notinn G_e$, then $\lookup{G_t}{t_n} = \lookup{G_p}{t_n} = \lookup{G_c}{t_n} = \emptyset$. In other words, a feature or a group which does not exist cannot have a name, a type, a parent, or a child.
   \item[\itbf{TFMWF9}] The temporal feature model contains no cycles, which means that at any time point $t_n \geq t_0$, for any feature or group that exists at $t_n$, if we follow the parent chain upwards, we never encounter the same feature or group twice. In other words, no feature or group is its own ancestor.
\end{enumerate}

Together, these requirements form the basis of the soundness proofs. We assume that the original plan is sound, so each of these requirements is assumed to be true for the original temporal feature model. Furthermore, we prove that the requirements must still hold for the updated model if the rule can be applied.

\paragraph{Soundness of the rules}
In the following sections, we prove that each rule is sound, and conclude that the system is sound.

For each rule, the proof for soundness includes three parts: 
\begin{enumerate}[(i)]
   \item proving that the rule operates strictly within the previously defined temporal and spatial scopes (section \vref{sec:define-the-scope}), 
   \item that the rule preserves well-formedness, as defined in the above requirements \itbf{TFMWF1-9}, and
   \item that the rule updates the model correctly, preserving soundness as well as respecting the semantics of the operation.
\end{enumerate}

\section{Soundness of the Add feature rule}
\label{sec:soundness-of-the-add-feature-rule}

\todo{Use a proof environment that clearly separate definitions from proofs. The proofs should contain syntactic correctness, not semantic (that part is moved out of the proof)}

See figure \vref{rule:add-feature} for the \rulefont{Add-Feature} rule.
Let 
\begin{equation*}
   \begin{split}
      \textbf{addFeature}(\var{featureID}, \var{name}, \var{type}, \var{parentGroupID})\text{ at }\interval{t_n}{t_m}
      \shove \\
   (\names{}, \features{}, \groups{})
\end{split}
\end{equation*}
be the initial state. Recall that this operation adds the feature with ID \var{featureID} to the temporal feature model $(\names{}, \features{}, \groups{})$ from $t_n$ to $t_m$. We assume that $(\names{}, \features{}, \groups{})$ is well-formed, as defined in \itbf{TFMWF1-9}.

\todo{Show that the feature model outside the scope is unchanged}

\paragraph{Scope}

Recall from section \vref{sec:define-the-scope} that the temporal scope of this operation is $\interval{t_n}{t_m}$, and the spatial scope is the feature itself, the parent group and the name. 

In the rule, we look up only the feature ID, the parent group ID, and the name, and update only the name, feature, and parent group. Thus, the rule operates within the spatial scope of the operation. Furthermore, the only interval looked up in the interval maps and sets of the model is $\interval{t_n}{t_m}$, which is exactly the temporal scope of the rule. Hence the rule operates strictly within the temporal and spatial scopes of the operation.
\\

\begin{lemma}
   The \rulefont{Add-Feature} rule operates strictly within the scope of the \textbf{addFeature} operation.
   \label{lemma:add-feature-scope}
\end{lemma}


\paragraph{Preserving well-formedness}

If the rule is applied, the well-formedness requirements must hold for the updated feature model. 

Since the rule checks that the feature does not already exist during the temporal scope, it is impossible that $\var{featureID} = \var{rootID}$. Thus the rule does not affect the root feature, and \itbf{TFMWF1} and \itbf{TFMWF2} hold for the updated temporal feature model.

Because we assume that \itbf{TFMWF8} holds for the original model, and the feature does not exist during $\interval{t_n}{t_m}$, the feature has no name, type, or subgroups in the original plan. When we add the feature to the feature model using \var{setFeatureAttributes}, we give the feature exactly one name and one type during the temporal scope, and the set of child groups is empty. The temporal scope is also added to the feature's existence set, so only the new feature has the ID $\var{featureID}$ during the temporal scope. To link the feature ID to the name, the rule sets the feature ID as the value at key $\var{name}$ in the $\names{}$ map during the temporal scope, so the name is unique during the temporal scope.
Consequently, \itbf{TFMWF3} holds.

The rule does not modify the parent group's variation type, so \itbf{TFMWF4} is preserved in the modified temporal feature model.

Similarly to the argument for \itbf{TFMWF3}, the parent group ID is uniquely defined for the feature in \var{setFeatureAttributes}, and \var{featureID} is added to the parent group's set of child features, so the new feature is part of exactly one group. Since we do not remove any other feature IDs from the parent group's set of features, and as we already established that the new feature is not the root feature, \itbf{TFMWF5} is preserved.

The new feature does not have any subgroups during the temporal scope, and we do not modify the parent group's parent feature. Under the assumption that \itbf{TFMWF6} holds in the original model, it still holds after applying the \rulefont{Add-Feature} rule.

The rule verifies that all of the parent group's types are compatible with the added feature's type during the temporal scope, so \itbf{TFMWF7} holds after applying the rule.

Since the rule adds the temporal scope to the new feature's existence table, and since the parent group exists in the original plan, \itbf{TFMWF8} is preserved after the rule is applied.

It is furthermore impossible that adding this feature creates a cycle in the modified model. The new feature has no subgroups, so it cannot be part of a cycle. Because of the assumption that \itbf{TFMWF9} holds in the original plan, and applying the rule does not introduce a cycle, this requirement still holds. 

As the rule operates within the scope (lemma \vref{lemma:add-feature-scope}), it does not affect any other part of the plan.

We conclude that the \rulefont{Add-Feature} rule preserves well-formedness for the temporal feature model, according to well-formedness rules \itbf{TFMWF1-9}. 
\\
\begin{lemma}
   The \rulefont{{Add-Feature}} rule preserves well-formedness of the temporal feature model.
   \label{lemma:add-feature-well-formed}
\end{lemma}

\todo{Mention that the scope part ensures that no other part of the plan is affected}
\paragraph{Correctness of model modification}

The operation is intended to add the feature with ID \var{featureID} to the temporal feature model during the interval $\interval{t_n}{t_m}$. 

After adding the feature to the temporal feature model, looking up the name $\var{name}$ in the $\names{}$ map at interval key $\interval{t_n}{t_m}$ should give the value $\var{featureID}$. Indeed, since the $\names{}$ map is updated thus:
\[
   \lookup{\lookup{\names}{\var{name}}}{\interval{t_n}{t_m}} \assign \var{featureID}
\]
, then due to the semantics of map assignment (definition \vref{def:map}), and lookup in interval maps (definition \vref{def:interval-map}),
\[
   \lookup{\lookup{\names}{\var{name}}}{\interval{t_n}{t_m}} = \set{\var{featureID}}
\]
will hold.

Similarly, if we wish to lookup information about the feature during the interval $\interval{t_n}{t_m}$ in the modified model, the results should match the information in the operation. The rule assigns 
\begin{equation*}
   \begin{split}
   \var{setFeatureAttributes}(\lookup{\features{}}{\var{featureID}}, \interval{t_n}{t_m}, \var{name}, \var{type}, \\
   \var{parentGroupID})
   \end{split}
\end{equation*}

to $\lookup{\features}{\var{featureID}}$. 

According to the semantics of assignment (section \vref{sub:maps}) and $\var{setFeatureAttributes}$ (figure \vref{fun:set-feature-attributes}), and given that $\lookup{\features}{\var{featureID}} = \feature$, then 
\begin{align}
   \interval{t_n}{t_m} &\in F_e && \text{the feature exists} \tag{1} \label{add-feature1}\\
   \lookup{F_n}{\interval{t_n}{t_m}} &= \set{\var{name}} && \text{the feature has the expected name} \tag{2} \label{add-feature2}\\
   \lookup{F_t}{\interval{t_n}{t_m}} &= \set{\var{type}}  && \text{the feature has the expected type} \tag{3} \label{add-feature3}\\
   \lookup{F_p}{\interval{t_n}{t_m}} &= \set{\var{parentGroupID}}  && \text{the feature has the expected parent group} \tag{4} \label{add-feature4}\\
   \lookup{F_c}{\interval{t_n}{t_m}} &= \emptyset && \text{the feature has no children} \tag{5} \label{add-feature5}
\end{align}

Statement (\ref{add-feature1}) holds due to the line $F_e \cup \interval{t_n}{t_m}$ in $\var{setFeatureAttributes}$. The next four hold due to both premises in the rule and modifications in the function. Due to the premise $\interval{t_n}{t_m} \not \innr F_e$, which means that the feature does not previously exist at any point during the interval, and since \itbf{TFMWF8} is assumed to hold for the original model, the original feature does not have a name, type, parent group or child groups during the interval. In the function $\var{setFeatureAttributes}$, the name is added ($\lookup{F_n}{\interval{t_{start}}{t_{end}}} \assign \var{name}$), and so is the type ($\lookup{F_t}{\interval{t_{start}}{t_{end}}} \assign \var{type}$) and the parent group ($\lookup{F_t}{\interval{t_{start}}{t_{end}}} \assign \var{parentGroupID}$). The child groups are not modified, and so (\ref{add-feature5}) holds.

The child features of the group must also be updated according to the semantics of the operation. After applying the rule, given that $\lookup{\groups}{\var{parentGroupID}} = \group{}$, 
\[
   \var{featureID} \in \bigcup \lookup{G_c}{\interval{t_n}{t_m}}
\]
, meaning that the feature is in the parent group's set of child features in the updated model. This holds because $\lookup{\groups}{\var{parentGroupID}}$ is assigned $\var{addChildFeature}(\lookup{\groups}{\var{parentGroupID}}, \interval{t_n}{t_m}, \var{featureID})$ (see figure \vref{fun:add-child-feature}), which modifies $G_c$ by adding $\var{featureID}$ to the set of child features at interval key $\interval{t_n}{t_m}$.
\\

\begin{lemma}
   The \rulefont{Add-Feature} rule updates the temporal feature model according to the semantics of the \textbf{addFeature} operation.
   \label{lemma:add-feature-mod}
\end{lemma}

\section{Soundness for the Add group rule}
\label{sec:soundness-for-the-add-group-rule}

See figure \vref{rule:add-group} for the \rulefont{Add-Group} rule. 
Let 
\begin{equation*}
   \begin{split}
      \textbf{addGroup}(\var{groupID}, \var{type}, \var{parentFeatureID})\text{ at }\interval{t_n}{t_m}
      \shove \\
   (\names{}, \features{}, \groups{})
\end{split}
\end{equation*}
be the initial state. Recall that this operation adds the group with ID \var{groupID} to the temporal feature model $(\names{}, \features{}, \groups{})$ from $t_n$ to $t_m$. As this rule does not remove or change the type of any feature, \itbf{WF1-3} and \itbf{WF5} hold trivially. Since we check that the group does not already exist ($\interval{t_n}{t_m} \notinnr G_e$), and the original temporal feature model is assumed to be sound, it is impossible that the added group has more than one type or parent. Furthermore, the function $\var{setGroupAttributes}$ sets the type and parent feature ID during the temporal scope, so the added group has at least one type and parent during that interval. The parent feature is looked up in the $\features{}$ map, and asserted to exist during the entire temporal scope ($\interval{t_n}{t_m} \inn F_e$). Thus, \itbf{WF4} and \itbf{WF6} hold. Since the group is added without child features, it does not contain child features during the temporal scope, and so \itbf{WF7} holds.

\todo{Veilederm√∏te: 

Prove that the rule only works within the scope, in particular the spatial scope. We've already defined the scope, but now I must prove that the rules only check within the scope. The rule should follow what I define.



Should divide the proof into parts: One that proves that the premises are sound, an one that checks that the transition does what it should.
}
