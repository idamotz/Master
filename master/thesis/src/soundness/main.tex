\chapter{Soundness}
\label{cha:soundness}
\todo{and completeness? The operations in themselves are not complete, in the sense that there is not a one-to-one correspondence between the operations defined on temporal feature models (temporal operations) and the operations defined on feature models (model operations). However, the temporal operations are more restricted than the model operations, and any valid change within that subset to an evolution plan would be accepted by the rules. Should I try to prove completeness as well?}

\todo{Root feature requirements}

\section{Soundness for temporal feature models}
\label{sec:soundness-for-temporal-feature-models}
\todo{Argue that the rules are \emph{enough} to preserve soundness.}
\todo{Show what needs to be proved for an initial model. ``correct by construction". In a well-formed structure. Lemma: What is a sound structure. Soundness theorem: Preserves soundness, using the lemma.}

The temporal feature model can be viewed as a sequence of feature models associated with time points. A feature model has strict structural requirements, and the definition of a paradox is a feature model that violates these requirements. In this context, soundness means that if a rule accepts a modification, realising the modified plan results in a sequence of feature models where each is structurally sound. The soundness analysis in this chapter assumes that the original plan is sound; i.e. all resulting feature models fulfil the structural requirements. 

We must first define what it means for a temporal feature model to be sound. Essentially, it means that if we converted the temporal feature model into a sequence of time points associated with feature model, each feature model would be sound.

According to \cite{art:consistency-preserving-evolution-planning}, the structural requirements (well-formedness rules) are 
\begin{enumerate}[\itbf{WF\arabic*}, itemsep=0mm]
   \item A feature model has exactly one root feature.
   \item The root feature must be mandatory.
   \item Each feature has exactly one unique name, variation type and (potentially empty) collection of subgroups.
   \item Features are organized in groups that have exactly one variation type.
   \item Each feature, except for the root feature, must be part of exactly one group.
   \item Each group must have exactly one parent feature.
   \item Groups with types \xortype{} or \ortype{} must not contain \mandatory{} features.
\end{enumerate}

Furthermore, a feature model is a tree structure and must not contain cycles. There is an additional requirement that groups with types \xortype{} or \ortype{} must contain at least two child features, but this is not taken into account in this thesis.

These requirements can be translated into rules for temporal feature models $(\names, \features, \groups)$. We assume that the first time point in the plan is $t_0$.

\begin{enumerate}[\itbf{WF\arabic*}, itemsep=0mm]
   \item A temporal feature model has exactly one root feature. We assume that the root ID is $\var{rootID}$, and that $\lookup{\features}{\var{rootID}} = \featurevar{R}$. This also means that $R_e=\set{\interval{t_0}{\forever}}$ \textemdash{} the root always exists, and that $R_p = \emptyset$ \textemdash{} the root never has a parent group.
\item The root feature must be mandatory. This means that $$R_t  = \set{\intervalmapping{t_0}{\forever}{\mandatory}}$$ where $R_t$ is the types map of the root feature. 
\item At any time $t_n \geq t_0$, each feature has exactly one unique name, variation type and (potentially empty) collection of subgroups. Given a feature ID $\var{featureID}$, this means that if $\lookup{\features}{\var{featureID}} = \feature$ and $t_n \inn F_e$ , then
   \begin{enumerate}[(i)]
      \item $\lookup{F_n}{t_n} = \set{\var{name}}$ \textemdash{} the feature has exactly one name,
      \item $\lookup{\lookup{\names}{\var{name}}}{t_n} = \set{\var{featureID}}$ \textemdash{} the name is unique \emph{at the time point $t_n$},
      \item $\lookup{F_t}{t_n} = \set{\var{type}} \text{ with } \var{type} \in \set{\mandatory, \optional}$ \textemdash{} the feature has exactly one type, and
      \item $\lookup{F_c}{t_n} = C$, such that $\bigcup C$ is a set of the group IDs, and if $\var{groupID} \in \bigcup C$ and $\lookup{\groups}{\var{groupID}} = \group{}$, then $\lookup{G_p}{t_n} = \set{\var{featureID}}$ \textemdash{} if a group is listed as a subgroup of a feature, then the feature is listed as the parent of the group at the same time.
   \end{enumerate}
   \item At any time $t_n \geq t_0$, each group has exactly one variation type. Given a group ID $\var{groupID}$, this means that if $\lookup{\groups}{\var{groupID}} = \group$ and $t_n \inn G_e$, then $\lookup{G_t}{t_n} = \set{\var{type}}$ for $\var{type} \in \set{\andtype, \ortype, \xortype}$.
   \item At any time $t_n \geq t_0$, each feature, except for the root feature, must be part of exactly one group. Formally, given a feature ID $\var{featureID} \neq \var{rootID}$, if $\lookup{\features}{\var{featureID}} = \feature$, and $t_n \inn F_e$, then $\lookup{F_p}{t_n} = \set{\var{groupID}}$ with $\lookup{\groups}{\var{groupID}} = \group$, $t_n \inn G_e$, and $\var{featureID} \in \bigcup \lookup{G_c}{t_n}$. 
   \item At any time $t_n \geq t_0$, each group must have exactly one parent feature. Formally, given a group ID $\var{groupID}$, if $\lookup{\groups}{\var{groupID}} = \group$ and $t_n \inn G_e$, then $\lookup{G_p}{t_n} = \set{\var{featureID}}$, and $\lookup{\features}{\var{featureID}} = \feature$ with $\var{groupID} \in \bigcup \lookup{F_c}{t_n}$.
   \item At any time $t_n$, a group with types \xortype{} or \ortype{} must not contain \mandatory{} features. Formally, given a group ID $\var{groupID}$ with $\lookup{\groups}{\var{groupID}} = \group$, if $\lookup{F_t}{t_n} \set{\var{type}}$ with $\var{type} \in \set{\xortype{}, \ortype{}}$, and if $\var{featureID} \in \bigcup \lookup{F_c}{t_n}$ and $\lookup{\features}{\var{featureID}} = \feature$, then $\lookup{F_t}{t_n} = \set{\optional}$.
\end{enumerate}

We must add two additional requirements:
\begin{enumerate}[itemsep=0mm]
   \item[\itbf{WF8}] For a feature with ID $\var{featureID}$ such that $\lookup{\features}{\var{featureID}} = \feature$, if $t_n \notinn F_e$, then $\lookup{F_n}{t_n} = \lookup{F_t}{t_n} = \lookup{F_p}{t_n} = \lookup{F_c}{t_n} = \emptyset$, and for all keys $\var{name}$ in $\names$, $\var{featureID} \notin \lookup{\lookup{\names}{\var{name}}}{t_n}$ \textemdash{} no name belongs to the feature. Similarly, for a group with ID $\var{groupID}$ such that $\lookup{\groups}{\var{groupID}} = \group$, if $t_n \notinn G_e$, then $\lookup{G_t}{t_n} = \lookup{G_p}{t_n} = \lookup{G_c}{t_n} = \emptyset$. In other words, a feature or a group which does not exist cannot have a name, a type, a parent, or a child.
   \item[\itbf{WF9}] The temporal feature model contains no cycles, which means that at any time point $t_n \geq t_0$, for any feature or group that exists at $t_n$, if we follow the parent chain upwards, we never encounter the same feature or group twice. In other words, no feature or group is its own ancestor.
\end{enumerate}

Together, these requirements form the basis of the soundness proofs. We assume that the original plan is sound, so each of these requirements is assumed to be true for the original temporal feature model. Furthermore, we prove that the requirements must still hold for the updated model if the rule can be applied.

\paragraph{Soundness of the rules}
For each rule, the proof for soundness includes three parts: 
\begin{enumerate}[(i)]
   \item proving that the rule operates strictly within the previously defined temporal and spatial scopes (section \vref{sec:define-the-scope}), 
   \item that the rule preserves well-formedness, as defined in the above requirements \itbf{WF1-9}, and
   \item that the rule updates the model correctly, preserving soundness as well as respecting the semantics of the operation.
\end{enumerate}

\section{Soundness of the Add feature rule}
\label{sec:soundness-of-the-add-feature-rule}

See figure \vref{rule:add-feature} for the \rulefont{Add-Feature} rule.
Let 
\begin{equation*}
   \begin{split}
      \textbf{addFeature}(\var{featureID}, \var{name}, \var{type}, \var{parentGroupID})\text{ at }\interval{t_n}{t_m}
      \shove \\
   (\names{}, \features{}, \groups{})
\end{split}
\end{equation*}
be the initial state. Recall that this operation adds the feature with ID \var{featureID} to the temporal feature model $(\names{}, \features{}, \groups{})$ from $t_n$ to $t_m$. We assume that $(\names{}, \features{}, \groups{})$ is well-formed, as defined in \itbf{WF1-9}.

\paragraph{Scope} 

Recall from section \vref{sec:define-the-scope} that the temporal scope of this operation is $\interval{t_n}{t_m}$, and the spatial scope is the feature itself, the parent group and the name. In the rule, we look up only the feature ID, the parent group ID, and the name, and update only the name, feature, and parent group. Thus, the rule operates within the spatial scope of the operation. Furthermore, the only interval looked up in the interval maps and sets of the model is $\interval{t_n}{t_m}$, which is exactly the temporal scope of the rule. Hence the rule operates strictly within the temporal and spatial scopes of the operation.

\paragraph{Preserving well-formedness}

If the rule is applied, the well-formedness requirements must hold for the updated feature model. 
Since the rule checks that the feature does not already exist during the temporal scope, it is impossible that $\var{featureID} = \var{rootID}$. Thus the rule does not affect the root feature, and \itbf{WF1} and \itbf{WF2} hold for the updated temporal feature model.

Because we assume that \itbf{WF8} holds for the original model, and the feature does not exist during $\interval{t_n}{t_m}$, the feature has no name, type, or subgroups in the original plan. When we add the feature to the feature model using \var{setFeatureAttributes}, we give the feature exactly one name and one type during the temporal scope, and the set of child groups is empty. The temporal scope is also added to the feature's existence set, so only the new feature has the ID $\var{featureID}$ during the temporal scope. To link the feature ID to the name, the rule sets the feature ID as the value at key $\var{name}$ in the $\names{}$ map during the temporal scope, so the name is unique during the temporal scope.
Consequently, \itbf{WF3} holds.

The rule does not modify the parent group's variation type, so \itbf{WF4} is preserved in the modified temporal feature model.

Similarly to the argument for \itbf{WF3}, the parent group ID is uniquely defined for the feature in \var{setFeatureAttributes}, and \var{featureID} is added to the parent group's set of child features, so the new feature is part of exactly one group. Since we do not remove any other feature IDs from the parent group's set of features, and as we already established that the new feature is not the root feature, \itbf{WF5} is preserved.

The new feature does not have any subgroups during the temporal scope, and we do not modify the parent group's parent feature. Under the assumption that \itbf{WF6} holds in the original model, it still holds after applying the \rulefont{Add-Feature} rule.

The rule verifies that all of the parent group's types are compatible with the added feature's type during the temporal scope, so \itbf{WF7} holds after applying the rule.

Since the rule adds the temporal scope to the new feature's existence table, and since the parent group exists in the original plan, \itbf{WF8} is preserved after the rule is applied.

It is furthermore impossible that adding this feature creates a cycle in the modified model. The new feature has no subgroups, so it cannot be part of a cycle. Because of the assumption that \itbf{WF9} holds in the original plan, and applying the rule does not introduce a cycle, this requirement still holds. 

We conclude that the \rulefont{Add-Feature} rule preserves well-formedness for the temporal feature model, according to well-formedness rules \itbf{WF1-9}.

\paragraph{Correctness of model modification}

The operation's intent is to add the feature with ID \var{featureID} to the temporal feature model during the interval $\interval{t_n}{t_m}$. We argue that the SOS rule does exactly that. The $\names{}$ map is meant to give complete information about which names are used in the feature model, and which feature each name belongs to at any time point. The only name added to the feature model when we add the new feature is \var{name}, and the new feature only uses this name during the temporal scope $\interval{t_n}{t_m}$. The rule should then reflect this, so the $\names{}$ map is updated at key \var{name} and $\interval{t_n}{t_m}$ with the value $\var{featureID}$.

\section{Soundness for the Add group rule}
\label{sec:soundness-for-the-add-group-rule}

See figure \vref{rule:add-group} for the \rulefont{Add-Group} rule. 
Let 
\begin{equation*}
   \begin{split}
      \textbf{addGroup}(\var{groupID}, \var{type}, \var{parentFeatureID})\text{ at }\interval{t_n}{t_m}
      \shove \\
   (\names{}, \features{}, \groups{})
\end{split}
\end{equation*}
be the initial state. Recall that this operation adds the group with ID \var{groupID} to the temporal feature model $(\names{}, \features{}, \groups{})$ from $t_n$ to $t_m$. As this rule does not remove or change the type of any feature, \itbf{WF1-3} and \itbf{WF5} hold trivially. Since we check that the group does not already exist ($\interval{t_n}{t_m} \notinnr G_e$), and the original temporal feature model is assumed to be sound, it is impossible that the added group has more than one type or parent. Furthermore, the function $\var{setGroupAttributes}$ sets the type and parent feature ID during the temporal scope, so the added group has at least one type and parent during that interval. The parent feature is looked up in the $\features{}$ map, and asserted to exist during the entire temporal scope ($\interval{t_n}{t_m} \inn F_e$). Thus, \itbf{WF4} and \itbf{WF6} hold. Since the group is added without child features, it does not contain child features during the temporal scope, and so \itbf{WF7} holds.

\todo{Veilederm√∏te: 

Prove that the rule only works within the scope, in particular the spatial scope. We've already defined the scope, but now I must prove that the rules only check within the scope. The rule should follow what I define.



Should divide the proof into parts: One that proves that the premises are sound, an one that checks that the transition does what it should.
}
